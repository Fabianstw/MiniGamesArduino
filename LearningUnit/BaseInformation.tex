\documentclass[10pt, oneside]{article} 
\usepackage{amsmath, amsthm, amssymb, calrsfs, wasysym, verbatim, bbm, color, graphics, geometry}
\usepackage[colorlinks=true, linkcolor=blue, urlcolor=blue, citecolor=blue]{hyperref} % Customize hyperref
\usepackage{csquotes} % For the \enquote command
\usepackage[dvipsnames]{xcolor} % For colored text
\usepackage{tcolorbox} % For custom boxes
\usepackage{multicol}

\usepackage{tikz}
\usetikzlibrary{arrows.meta, decorations.markings}
\tikzset{
    vector/.style={thick,->},
    angle/.style={thin, red},
    angle label/.style={font=\small, red},
}

\usepackage{multicol}

\newtheorem{theorem}{Theorem}
\newtheorem*{theorem*}{Theorem}

\theoremstyle{remark}
\newtheorem*{own_abstract}{Abstract}
\newtheorem*{proofsketch}{Proof Sketch}

% Define the new command for boxed notes
\newcommand{\myBoxedNote}[1]{%
  \hspace{40pt} \boxed{\textbf{Sidenote: } #1}%
}

% counter for definitions
\newcounter{definition}
% Define the new environment for definitions
\newtcolorbox{myDef}[1][]{
  colback=gray!10!white, colframe=gray!80!black, fonttitle=\bfseries,
  title=Definition \thedefinition\ifstrempty{#1}{}{ (#1)},
  rounded corners, before upper={\stepcounter{definition}}
}

% counter for theorems
\newcounter{theoremCounter}

% define the new environment for theorems
\newtcolorbox{myTheo}[1][]{
  colback=red!10!white, colframe=red!50!black, fonttitle=\bfseries,
  title=Theorem \thetheoremCounter\ifstrempty{#1}{}{ (#1)},
  rounded corners, before upper={\stepcounter{theoremCounter}}
}

\newcounter{claimCounter}
\newtcolorbox{myClaim}[1][]{
  colback=white, colframe=black, fonttitle=\bfseries,
  title=Claim \theclaimCounter\ifstrempty{#1}{}{ (#1)},
  rounded corners, before upper={\stepcounter{claimCounter}}
}

\geometry{tmargin=.75in, bmargin=.75in, lmargin=.75in, rmargin = .75in}  

\newtheorem{thm}{Theorem}
\newtheorem{defn}{Definition}
\newtheorem{conv}{Convention}
\newtheorem{rem}{Remark}
\newtheorem{lem}{Lemma}
\newtheorem{cor}{Corollary}

\title{Base information about the Learning Unit}
\author{Fabian Stiewe}
\date{Academic Year 2024-2025}

\begin{document}

\maketitle
\tableofcontents

\section{School and Year}
This learning unit is designed for the 4th year of the \textbf{LSSA - Liceo Scientifico Scienze Applicate}. It will be taught at the beginning of the academic year.

\section{Topics to be covered}
The main topic is theoretical computer science, inside this huge field we will focus on the following topics:
\begin{itemize}
  \item Sorting algorithms
  \begin{itemize}
    \item Bubble sort
    \item Selection sort
    \item Merge sort
    \item Sorting on presorted data
  \end{itemize}    
  \item Searching algorithms
  \begin{itemize}
    \item Linear search
    \item Binary search
    \item Hash tables
  \end{itemize}
\end{itemize}

\subsection{Objectives Sorting Algorithms}

\subsubsection{Bubble Sort}
The students should understand how the \textbf{bubble sort} algorithm works and be able to implement it in their preferred programming language. They should also be able to analyze the time complexity \textit{(not with big-O notation)} of the algorithm and understand why it is not efficient for large data sets.

\subsubsection{Selection Sort}
The students should understand how the \textbf{selection sort} algorithm works and be able to implement it in their preferred programming language. They should also be able to analyze the time complexity \textit{(not with big-O notation)} of the algorithm and understand why it is not efficient for large data sets.

\subsubsection{Merge Sort}
The students should understand how the \textbf{merge sort} algorithm works and be able to implement it in their preferred programming language. A time complexity is \textbf{not} required, but the students should understand that it is more efficient than bubble sort and selection sort.

\subsubsection{Sorting on Presorted Data}
Given different data sets, the students should be able to choose the best sorting algorithm for each data set. They should also be able to explain why a specific sorting algorithm is better for a specific data set.

In example: If the data set is already sorted, except for $k$ elements, which sorting algorithm should be used?

\subsection{Objectives Searching Algorithms}

\subsubsection{Linear Search}
The students should understand how the \textbf{linear search} algorithm works and be able to implement it in their preferred programming language. They should also be able to analyze the time complexity \textit{(not with big-O notation)} of the algorithm and understand why it is not efficient for large data sets.

\subsubsection{Binary Search}
The students should understand how the \textbf{binary search} algorithm works and be able to implement it in their preferred programming language. They should also be able to analyze the time complexity \textit{(not with big-O notation)} of the algorithm and understand why it is more efficient than linear search.

\subsubsection{Hash Tables}
The students should understand how \textbf{hash tables} work and be able to use them in their preferred programming language. They should understand why it is efficient for searching and inserting elements and be able to explain why it is more efficient than binary search (in special cases).

\subsection{Short Objectives Summary}
The students will be able to implement different sorting and searching algorithms and will see cases from real application where those algorithms are used.

\section{Perquisites}
There are no formal prerequisites for this learning unit. However, it is recommended that students have a basic understanding of the following topics:
\begin{itemize}
  \item Basic programming concepts
  \begin{itemize}
    \item The programming language does not matter, each student can use the language they are most comfortable with
    \item Variables, loops, functions, arrays, etc. should be known
  \end{itemize}
  \item Basic mathematics concepts
  \begin{itemize}
    \item Basic algebra
    \item $\log$ function
    \item Very basic probability (there won't be a proof for hash tables, but it helps to understand the concept)
  \end{itemize}
\end{itemize}

\section{Time plan for the Learning Unit}
The learning unit will take 9 weeks. Each week will be divided into two parts: \textbf{theory} and \textbf{practice}. The theory part will be taught first, and the practice part will be taught (in the laboratory) in the second half of the week. During the practice part, the students will get a simple problem and should implement a solution using the algorithms they learned in the theory part.

\subsection{Week 1: Bubble Sort}
Using a presentation, the students will get taught how the bubble sort algorithm works. They will also get some examples and the \enquote{Pseudocode} of the algorithm. 

The students will play two little games, first they will sort each other by height using the bubble sort algorithm. Second they will learn the algorithm (\textit{also at home}) using the platform \href{https://tcs.uni-frankfurt.de/algo-learn-testing/refs_heads_feat-bubbleSort/en
}{algo learn} \textbf{(Only the part for sorting algorithms)}.

In the laboratory, the students will get a simple problem and should implement a solution using the bubble sort algorithm.

\subsubsection*{Problem for the laboratory}
\begin{tcolorbox}
  To start the course the students will get a simple problem: Given an array of integers, sort the array using the bubble sort algorithm. The array should be sorted in ascending order. 

  For those who are fast: Given an array of tuples, the first entry is a string and the second entry is an integer. First sort the array by the integer in ascending order, then sort the array by the string in descending order.
\end{tcolorbox}
This is a good start to warm up programming skills of each student.

\subsection{Week 2: Selection Sort}
Using a presentation, the students will get taught how the selection sort algorithm works. They will also get some examples and the \enquote{Pseudocode} of the algorithm. Also, an application example will be shown, quite similar to the problem for the laboratory. 

They will again use the platform \href{https://tcs.uni-frankfurt.de/algo-learn-testing/refs_heads_feat-bubbleSort/en
}{algo learn} to learn the \textbf{selection sort} algorithm. \textit{(No question yet programmed.)}

\subsubsection*{Problem for the laboratory}
\begin{tcolorbox}
  You are given an array of strings \texttt{names}, and an array \texttt{heights} that consists of distinct positive integers. Both arrays are of length $n$. For each index $i$, \texttt{names}$[i]$ and \texttt{heights}$[i]$ denote the name and height of the $i$th person. Return \texttt{names} sorted in descending order by the people's heights.
\end{tcolorbox}
The problem will should be solved using the selection sort algorithm. The students will get test cases to check if their implementation is correct.

\subsection{Week 3: Merge Sort}
Again using a presentation and the following YouTube video: \href{https://www.youtube.com/watch?v=ZRPoEKHXTJg}{Merge Sort Animations}. The students will get taught how the merge sort algorithm works. They will also get some examples and the \enquote{Pseudocode} of the algorithm.

They will again use the platform \href{https://tcs.uni-frankfurt.de/algo-learn-testing/refs_heads_feat-bubbleSort/en
}{algo learn} to learn the \textbf{merge sort} algorithm. \textit{(No question yet programmed.)}

\subsubsection*{Problem for the laboratory}
\begin{tcolorbox}
  You are given an array of integers. Sort the array using the merge sort algorithm. The array should be sorted in ascending order. 

  For those who are fast: Count how many inversions are in the array. An inversion is a pair of indices $(i, j)$ such that $i < j$ and $a[i] > a[j]$.
\end{tcolorbox}

\subsection{Week 4: Sorting on Presorted Data}
Todo

\subsection{Week 5: Recap and evaluation of the sorting algorithms}
Todo

\subsection{Week 6: Linear Search}
Todo

\subsection{Week 7: Binary Search}
Todo

\subsection{Week 8: Hash Tables}
Todo

\subsection{Week 9: Recap and evaluation of the searching (and sorting) algorithms}
Todo

\section{Disabilities}
Todo

\section{Evaluation}
\subsection{Outline}
The main part of the evaluation will be the programming during the laboratory. The students will get a problem and should implement a solution using the algorithms they learned in the theory part. The implementation should be correct and efficient, or at least the students should be able to explain why their implementation is not efficient. 

Above that, the Mini-Tests (in week 5 and 9) will be used to evaluate the understanding of the algorithms. The students should be able to explain how the algorithms work and why they are efficient or not efficient. 

\subsection{Mini-Test Week 5}
\subsubsection{No. 1 - Bubble Sort}
You are given the following list of numbers: 
\begin{align*}
  [5, 3, 8, 2, 1, 4, 7, 6]
\end{align*}
\begin{enumerate}
  \item Sort the list using the bubble sort algorithm. Write down the list after each iteration.
  \item What is the time complexity of the bubble sort algorithm?
  \item Why is the bubble sort algorithm not efficient for large data sets?
  \item What is the best case time complexity of the bubble sort algorithm?
\end{enumerate}

\subsubsection{No. 2 - Selection Sort}
You are given the following list of numbers:
\begin{align*}
  [12, 3, 5, 7, 1, 9, 4, 6]
\end{align*}
\begin{enumerate}
  \item Please sort the list using the selection sort algorithm. Write down the list after each iteration.
  \item Explain the difference between the bubble sort and the selection sort algorithm.  
\end{enumerate}

\subsubsection{No. 3 - Merge Sort}
You are given the following list of numbers:
\begin{align*}
  [8, 2, 4, 6, 3, 1, 5, 7]
\end{align*}
\begin{enumerate}
  \item Please sort the list using the merge sort algorithm. Write down the list after each iteration.
  \item What is the time complexity of the merge sort algorithm?
  \item Why is the merge sort algorithm more efficient than the bubble sort and selection sort algorithm?
\end{enumerate}

\subsubsection{No. 4 - Sorting on Presorted Data}
Given will be the following list of numbers, choose the best sorting algorithm for each list and explain why you choose this algorithm.
\begin{enumerate}
  \item $[1, 2, 3, 4, 5, 6, 7, 8]$
  \item $[8, 7, 6, 5, 4, 3, 2, 1]$
  \item $[8, 2, 4, 6, 3, 1, 5, 7]$
\end{enumerate}

\subsection{Mini-Test Week 9}
This will be created during the course.

\end{document}